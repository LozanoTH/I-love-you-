<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galaxia del Amor - Mejorada</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body, html {
            height: 100%;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #0a0e2a 0%, #000000 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        
        canvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        .header {
            position: fixed;
            top: 20px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        
        .title {
            font-size: 2.5rem;
            font-weight: 700;
            text-shadow: 0 0 20px #ff0066, 0 0 40px #ff0066;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #ff0066, #ff9900, #ff0066);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleGlow 3s ease-in-out infinite alternate;
        }
        
        @keyframes titleGlow {
            0% { filter: drop-shadow(0 0 10px #ff0066); }
            100% { filter: drop-shadow(0 0 20px #ff9900); }
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .player {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 600px;
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 18px 25px;
            border: 2px solid rgba(255, 102, 0, 0.7);
            border-radius: 50px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(15px);
            box-shadow: 
                0 0 25px rgba(255, 102, 0, 0.6),
                0 0 50px rgba(255, 51, 0, 0.3),
                inset 0 0 20px rgba(255, 102, 0, 0.1);
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .player:hover {
            transform: translateX(-50%) scale(1.02);
            box-shadow: 
                0 0 35px rgba(255, 102, 0, 0.8),
                0 0 70px rgba(255, 51, 0, 0.5),
                inset 0 0 30px rgba(255, 102, 0, 0.15);
        }
        
        .player button {
            background: linear-gradient(135deg, #ff6600, #ff3300);
            border: 2px solid rgba(255, 136, 51, 0.8);
            color: #fff;
            font-size: 24px;
            width: 55px;
            height: 55px;
            border-radius: 50%;
            cursor: pointer;
            filter: drop-shadow(0 0 10px rgba(255, 102, 0, 0.8));
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .player button:hover {
            transform: scale(1.15);
            background: linear-gradient(135deg, #ff8833, #ff6600);
            filter: drop-shadow(0 0 15px rgba(255, 51, 0, 1));
            box-shadow: 0 0 20px rgba(255, 102, 0, 0.6);
        }
        
        .player button:active {
            transform: scale(0.95);
        }
        
        .progress-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .progress {
            height: 16px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            overflow: hidden;
            cursor: pointer;
            position: relative;
            border: 1px solid rgba(255, 102, 0, 0.3);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .progress:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 102, 0, 0.5);
        }
        
        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, 
                #ff6600 0%, 
                #ff3300 25%, 
                #ff0099 50%, 
                #ff3300 75%, 
                #ff6600 100%);
            background-size: 400% 100%;
            border-radius: 20px;
            box-shadow: 
                0 0 15px rgba(255, 102, 0, 0.8),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            animation: flowing 4s ease-in-out infinite;
            position: relative;
            transition: width 0.1s linear;
        }
        
        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.4) 50%, 
                transparent 100%);
            animation: shine 2s ease-in-out infinite;
        }
        
        @keyframes flowing {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .time {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 8px rgba(255, 102, 0, 0.7);
        }
        
        .instructions {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 14px;
            opacity: 0.7;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .subtitle {
                font-size: 1rem;
            }
            
            .player {
                padding: 15px 20px;
                gap: 12px;
            }
            
            .player button {
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            .instructions {
                font-size: 12px;
                bottom: 110px;
                width: 90%;
            }
        }
        
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s ease;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(255, 102, 0, 0.3);
            border-radius: 50%;
            border-top-color: #ff6600;
            animation: spin 1s ease-in-out infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 18px;
            color: #ff6600;
            text-shadow: 0 0 10px rgba(255, 102, 0, 0.7);
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <div class="loading-text">Cargando Galaxia del Amor...</div>
    </div>
    
    <div class="header">
        <h1 class="title">Galaxia del Amor</h1>
        <div class="subtitle">Un viaje estelar de emociones</div>
    </div>
    
    <canvas id="c"></canvas>
    
    <div class="instructions">
        Arrastra para rotar ‚Ä¢ Rueda del mouse para acercar/alejar ‚Ä¢ Doble toque en m√≥vil para interactuar
    </div>
    
    <div class="player">
        <button id="play">‚ñ∂Ô∏è</button>
        <div class="progress-container">
            <div class="progress" id="progress">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <div class="time">
                <span id="current-time">0:00</span>
                <span id="total-time">0:00</span>
            </div>
        </div>
    </div>
    
    <audio id="audio" loop preload="metadata">
        <source src="https://www.dropbox.com/scl/fi/qfv28rqu6b36jwusao4x4/Love.MP3?rlkey=ptjd053374f028aa4jfcfrfxn&st=1j0j51eo&raw=1" type="audio/mpeg">
    </audio>

    <script src="https://cdn.jsdelivr.net/npm/three@0.148.0/build/three.min.js"></script>
    <script>
        // Esperar a que cargue la p√°gina
        window.addEventListener('load', () => {
            // Ocultar pantalla de carga despu√©s de un breve retraso
            setTimeout(() => {
                document.getElementById('loading').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 500);
            }, 1500);
            
            // Inicializar la aplicaci√≥n
            init();
        });

        function init() {
            // Configuraci√≥n de audio
            const audio = document.getElementById('audio');
            const playBtn = document.getElementById('play');
            const progress = document.getElementById('progress');
            const progressBar = document.getElementById('progress-bar');
            const currentTimeEl = document.getElementById('current-time');
            const totalTimeEl = document.getElementById('total-time');
            let isPlaying = false;

            // Formatear tiempo
            function formatTime(seconds) {
                if (!isFinite(seconds)) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return mins + ':' + secs.toString().padStart(2, '0');
            }

            // Control de reproducci√≥n
            playBtn.addEventListener('click', async () => {
                if (isPlaying) {
                    audio.pause();
                    playBtn.textContent = '‚ñ∂Ô∏è';
                } else {
                    try {
                        await audio.play();
                        playBtn.textContent = '‚è∏Ô∏è';
                    } catch (error) {
                        console.error('Error al reproducir audio:', error);
                    }
                }
                isPlaying = !isPlaying;
            });

            // Actualizar barra de progreso
            audio.addEventListener('timeupdate', () => {
                const percent = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = (isFinite(percent) ? percent : 0) + '%';
                currentTimeEl.textContent = formatTime(audio.currentTime);
                totalTimeEl.textContent = formatTime(audio.duration);
            });

            // Saltar a posici√≥n en la barra de progreso
            progress.addEventListener('click', (e) => {
                const rect = progress.getBoundingClientRect();
                const clickX = (e.clientX - rect.left) / rect.width;
                if (isFinite(audio.duration)) {
                    audio.currentTime = clickX * audio.duration;
                }
            });

            // Configuraci√≥n de Three.js
            const canvas = document.getElementById('c');
            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: false,
                powerPreference: "high-performance"
            });

            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 8000);

            let targetDist = 320;
            let currentDist = 320;
            let rotX = 0.15;
            let rotY = 0;

            // Fondo espacial mejorado
            function createSpaceBackground() {
                const canvas = document.createElement('canvas');
                canvas.width = 2048;
                canvas.height = 2048;
                const ctx = canvas.getContext('2d');
                
                // Crear gradiente espacial profundo
                const gradient = ctx.createRadialGradient(1024, 1024, 0, 1024, 1024, 1024);
                gradient.addColorStop(0, 'rgba(30,20,60,1)');
                gradient.addColorStop(0.3, 'rgba(15,10,40,1)');
                gradient.addColorStop(0.6, 'rgba(5,5,25,1)');
                gradient.addColorStop(1, 'rgba(0,0,10,1)');
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, 2048, 2048);
                
                // A√±adir nubes de nebulosa
                for (let i = 0; i < 8; i++) {
                    const x = Math.random() * 2048;
                    const y = Math.random() * 2048;
                    const size = 200 + Math.random() * 400;
                    
                    const nebulaGrad = ctx.createRadialGradient(x, y, 0, x, y, size);
                    nebulaGrad.addColorStop(0, `rgba(${100 + Math.random() * 100}, ${50 + Math.random() * 100}, ${150 + Math.random() * 100}, 0.3)`);
                    nebulaGrad.addColorStop(0.5, `rgba(${50 + Math.random() * 100}, ${20 + Math.random() * 80}, ${100 + Math.random() * 100}, 0.1)`);
                    nebulaGrad.addColorStop(1, 'rgba(0,0,0,0)');
                    
                    ctx.fillStyle = nebulaGrad;
                    ctx.fillRect(0, 0, 2048, 2048);
                }
                
                return new THREE.CanvasTexture(canvas);
            }

            scene.background = createSpaceBackground();

            // Campo de estrellas mejorado
            function createStarField(count = 3000, radius = 4000) {
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const sizes = new Float32Array(count);
                
                const starColors = [
                    [1, 1, 1],      // Blanco
                    [1, 0.8, 0.6],  // Blanco c√°lido
                    [0.8, 0.8, 1],  // Azul
                    [1, 1, 0.8],    // Amarillo
                    [1, 0.6, 0.8],  // Rosa
                ];
                
                for (let i = 0; i < count; i++) {
                    const distance = radius * (0.2 + 0.8 * Math.random());
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    positions[i * 3] = distance * Math.sin(phi) * Math.cos(theta);
                    positions[i * 3 + 1] = distance * Math.cos(phi);
                    positions[i * 3 + 2] = distance * Math.sin(phi) * Math.sin(theta);
                    
                    const colorIndex = Math.floor(Math.random() * starColors.length);
                    colors[i * 3] = starColors[colorIndex][0];
                    colors[i * 3 + 1] = starColors[colorIndex][1];
                    colors[i * 3 + 2] = starColors[colorIndex][2];
                    
                    sizes[i] = Math.random() * 3 + 0.5;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                
                const material = new THREE.PointsMaterial({
                    size: 2,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9,
                    sizeAttenuation: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending
                });
                
                scene.add(new THREE.Points(geometry, material));
            }

            createStarField();

            // N√∫cleo central mejorado
            const coreMat = new THREE.MeshPhongMaterial({
                color: 0x4444ff,
                transparent: true,
                opacity: 0.7,
                shininess: 300,
                emissive: 0x221144,
                specular: 0x8888ff
            });

            const core = new THREE.Mesh(
                new THREE.IcosahedronGeometry(42, 2),
                coreMat
            );
            scene.add(core);

            // Iluminaci√≥n mejorada
            const ambientLight = new THREE.AmbientLight(0x404080, 0.3);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xff6600, 1.5, 1000);
            pointLight1.position.set(200, 100, 200);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x6666ff, 1, 800);
            pointLight2.position.set(-150, -100, -150);
            scene.add(pointLight2);

            // Texto central mejorado
            function makeCenterTextTexture(text) {
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                // Limpiar y establecer brillo de fondo
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // A√±adir efecto de brillo de fondo
                const bgGrad = ctx.createRadialGradient(512, 256, 0, 512, 256, 400);
                bgGrad.addColorStop(0, 'rgba(255,0,100,0.3)');
                bgGrad.addColorStop(0.7, 'rgba(255,100,0,0.1)');
                bgGrad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Texto principal
                ctx.font = 'bold 120px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Capas de sombra para profundidad
                ctx.fillStyle = '#ff0066';
                ctx.shadowColor = '#ff66aa';
                ctx.shadowBlur = 60;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;
                
                ctx.fillText(text, canvas.width/2, canvas.height/2);
                
                // Superposici√≥n brillante
                ctx.shadowBlur = 30;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.fillStyle = '#ffaacc';
                ctx.fillText(text, canvas.width/2, canvas.height/2);
                
                return new THREE.CanvasTexture(canvas);
            }

            const centerTex = makeCenterTextTexture('TE AMO ‚ù§Ô∏è');
            const centerMat = new THREE.SpriteMaterial({
                map: centerTex,
                transparent: true,
                depthTest: false
            });
            const centerSprite = new THREE.Sprite(centerMat);
            centerSprite.scale.set(80, 40, 1);
            centerSprite.position.set(0, 0, 0);
            centerSprite.renderOrder = 999;
            scene.add(centerSprite);

            // Efecto de brillo mejorado con m√∫ltiples capas
            function makeEnhancedGlow(size = 1024) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                const centerX = size / 2;
                const centerY = size / 2;
                
                // M√∫ltiples capas de brillo
                const glows = [
                    { radius: size * 0.4, color: 'rgba(255,102,0,0.8)' },
                    { radius: size * 0.3, color: 'rgba(255,51,0,0.6)' },
                    { radius: size * 0.2, color: 'rgba(255,204,102,0.4)' },
                    { radius: size * 0.1, color: 'rgba(255,255,255,0.3)' }
                ];
                
                glows.forEach(glow => {
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, glow.radius
                    );
                    gradient.addColorStop(0, glow.color);
                    gradient.addColorStop(1, 'rgba(0,0,0,0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, size, size);
                });
                
                return new THREE.CanvasTexture(canvas);
            }

            const glowSprite = new THREE.Sprite(new THREE.SpriteMaterial({
                map: makeEnhancedGlow(),
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            }));
            glowSprite.scale.set(600, 600, 1);
            scene.add(glowSprite);

            // Texturas de anillos mejoradas con mejores gradientes
            function createRingTexture(size = 1024, innerRadius = 0.35, outerRadius = 0.48) {
                const canvas = document.createElement('canvas');
                canvas.width = canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                ctx.translate(size/2, size/2);
                
                const inner = size * innerRadius;
                const outer = size * outerRadius;
                
                // Gradiente principal del anillo
                const gradient = ctx.createRadialGradient(0, 0, inner * 0.8, 0, 0, outer);
                gradient.addColorStop(0, 'rgba(255,255,255,0)');
                gradient.addColorStop(0.1, 'rgba(255,204,102,1)');
                gradient.addColorStop(0.4, 'rgba(255,102,0,0.9)');
                gradient.addColorStop(0.7, 'rgba(255,51,0,0.7)');
                gradient.addColorStop(1, 'rgba(0,0,0,0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, outer, 0, Math.PI * 2);
                ctx.arc(0, 0, inner, 0, Math.PI * 2, true);
                ctx.closePath();
                ctx.fill();
                
                // A√±adir efecto de destello
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                for (let i = 0; i < 20; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = inner + Math.random() * (outer - inner);
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 1 + Math.random() * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                return new THREE.CanvasTexture(canvas);
            }

            // Anillos mejorados
            const ring1 = new THREE.Mesh(
                new THREE.RingGeometry(62, 85, 128),
                new THREE.MeshBasicMaterial({
                    map: createRingTexture(1024, 0.35, 0.48),
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                })
            );

            const ring2 = new THREE.Mesh(
                new THREE.RingGeometry(90, 108, 128),
                new THREE.MeshBasicMaterial({
                    map: createRingTexture(1024, 0.38, 0.45),
                    transparent: true,
                    side: THREE.DoubleSide,
                    opacity: 0.7,
                    blending: THREE.AdditiveBlending
                })
            );

            ring1.rotation.x = ring2.rotation.x = Math.PI / 2;
            scene.add(ring1);
            scene.add(ring2);

            // Sistema de palabras mejorado con mejor variedad
            const WORDS = [];
            const baseWords = [
                "üíñ Mi amor", "üåû Mi sol", "üåé Mi mundo", "‚ú® Brillas", "‚ù§Ô∏è Te amo",
                "üåå Universo", "üëë Reina", "üå† Estrella", "üí´ Mi cielo", "üî• Siempre t√∫",
                "üé∂ Tu risa", "ü¶ã Libertad", "üíé Eres todo", "üôè Gracias", "üíï Cari√±o",
                "üåπ Amor eterno", "ü§ó Abrazos", "üå∏ Esperanza", "üåà Alegr√≠a", "üåü Contigo",
                "üß∏ Ternura", "üéÅ Mi raz√≥n", "üåô Mi destino", "üíå Recuerdos", "üïäÔ∏è Mi paz",
                "ü™ê Mi universo", "üåä Mi calma", "üí° Mi luz", "üçí Dulzura", "ü•∞ Mi vida",
                "üéá Felicidad", "üåª Alegr√≠a", "üå∫ Mi flor", "üíú Eternidad", "üåü Sue√±os",
                "‚ú® Magia", "üéµ Canci√≥n", "üî• Pasi√≥n", "‚≠ê Mi estrella", "üå¥ Mi para√≠so",
                "üåÑ Amanecer", "üåÉ Noche contigo", "üéâ Mi fiesta", "üí´ Inspiraci√≥n",
                "üå∑ Siempre juntos", "üéÄ Mi ternura", "üçÄ Mi fortuna", "ü™û Mi reflejo"
            ];

            // Expandir array de palabras
            for (let i = 0; i < 8; i++) {
                WORDS.push(...baseWords);
            }

            // Creaci√≥n de texturas de texto mejorada
            function makeTextTexture(text, shadowColor) {
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Brillo de fondo
                const bgGrad = ctx.createRadialGradient(512, 128, 0, 512, 128, 300);
                bgGrad.addColorStop(0, shadowColor + '30');
                bgGrad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = bgGrad;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Estilo de texto
                ctx.font = 'bold 80px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // M√∫ltiples capas de sombra para profundidad
                ctx.fillStyle = shadowColor + 'AA';
                ctx.shadowColor = shadowColor;
                ctx.shadowBlur = 40;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                ctx.fillText(text, canvas.width/2, canvas.height/2);
                
                // Primer plano brillante
                ctx.shadowBlur = 20;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.fillStyle = '#ffffff';
                ctx.fillText(text, canvas.width/2, canvas.height/2);
                
                return new THREE.CanvasTexture(canvas);
            }

            // Paleta de colores mejorada
            const COLORS = [
                '#ff66ff', '#66ccff', '#ffd36b', '#ff9966', '#8df59a',
                '#ffa0f8', '#c6a7ff', '#ff4444', '#44ff99', '#99ccff',
                '#ffaa44', '#aa44ff', '#44ffaa', '#ff44aa', '#aaff44'
            ];

            // Crear sprites de texto con posicionamiento mejorado
            const textGroup = new THREE.Group();
            scene.add(textGroup);

            for (let i = 0; i < WORDS.length; i++) {
                const texture = makeTextTexture(WORDS[i], COLORS[i % COLORS.length]);
                const material = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    depthTest: false
                });
                
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(60, 20, 1);
                
                // Mejor distribuci√≥n en el espacio 3D
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * Math.PI * 2;
                const radius = 180 + 150 * Math.random();
                
                sprite.position.set(
                    radius * Math.sin(phi) * Math.cos(theta),
                    radius * Math.cos(phi),
                    radius * Math.sin(phi) * Math.sin(theta)
                );
                
                sprite.userData = {
                    phi: phi,
                    theta: theta,
                    radius: radius,
                    speed: 0.0008 + 0.0012 * Math.random(),
                    originalScale: sprite.scale.clone(),
                    pulseOffset: Math.random() * Math.PI * 2
                };
                
                textGroup.add(sprite);
            }

            // Sistema de interacci√≥n mejorado
            let dragging = false;
            let lastX = 0;
            let lastY = 0;

            function onDown(event) {
                dragging = true;
                const pos = event.touches ? event.touches[0] : event;
                lastX = pos.clientX;
                lastY = pos.clientY;
            }

            function onMove(event) {
                if (!dragging) return;
                
                const pos = event.touches ? event.touches[0] : event;
                const deltaX = (pos.clientX - lastX) / window.innerWidth;
                const deltaY = (pos.clientY - lastY) / window.innerHeight;
                
                rotY -= deltaX * 4;
                rotX = Math.max(-1.4, Math.min(1.4, rotX - deltaY * 3));
                
                lastX = pos.clientX;
                lastY = pos.clientY;
            }

            function onUp() {
                dragging = false;
            }

            // Event listeners
            window.addEventListener('mousedown', onDown);
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
            window.addEventListener('touchstart', onDown, {passive: true});
            window.addEventListener('touchmove', onMove, {passive: true});
            window.addEventListener('touchend', onUp, {passive: true});

            // Zoom mejorado con respuesta m√°s suave
            window.addEventListener('wheel', (event) => {
                targetDist += event.deltaY * 0.3;
                targetDist = Math.max(180, Math.min(700, targetDist));
            }, {passive: true});

            // Zoom t√°ctil
            let pinchDistance = 0;
            window.addEventListener('touchmove', (event) => {
                if (event.touches && event.touches.length === 2) {
                    event.preventDefault();
                    const dx = event.touches[0].clientX - event.touches[1].clientX;
                    const dy = event.touches[0].clientY - event.touches[1].clientY;
                    const distance = Math.hypot(dx, dy);
                    
                    if (pinchDistance) {
                        targetDist += (pinchDistance - distance) * 0.8;
                        targetDist = Math.max(180, Math.min(700, targetDist));
                    }
                    pinchDistance = distance;
                }
            }, {passive: false});

            window.addEventListener('touchend', () => {
                pinchDistance = 0;
            }, {passive: true});

            // Bucle de animaci√≥n mejorado
            let time = 0;

            function animate() {
                requestAnimationFrame(animate);
                
                // Movimiento suave de la c√°mara
                currentDist += (targetDist - currentDist) * 0.05;
                
                // Calcular posici√≥n de la c√°mara
                const camX = currentDist * Math.sin(rotX) * Math.cos(rotY);
                const camY = currentDist * Math.cos(rotX);
                const camZ = currentDist * Math.sin(rotX) * Math.sin(rotY);
                
                camera.position.set(camX, camY, camZ);
                camera.lookAt(0, 0, 0);
                
                // Rotar anillos
                ring1.rotation.z += 0.002;
                ring2.rotation.z -= 0.003;
                
                // Animar n√∫cleo
                core.rotation.y += 0.005;
                core.scale.setScalar(1 + 0.05 * Math.sin(time * 0.003));
                
                // Animar sprites de texto
                textGroup.children.forEach((sprite, i) => {
                    const data = sprite.userData;
                    
                    // Rotar alrededor del centro
                    data.theta += data.speed;
                    
                    // Actualizar posici√≥n
                    sprite.position.set(
                        data.radius * Math.sin(data.phi) * Math.cos(data.theta),
                        data.radius * Math.cos(data.phi),
                        data.radius * Math.sin(data.phi) * Math.sin(data.theta)
                    );
                    
                    // Mirar hacia la c√°mara
                    sprite.lookAt(camera.position);
                    
                    // Efecto de pulso
                    const pulse = 1 + 0.2 * Math.sin(time * 0.002 + data.pulseOffset);
                    sprite.scale.copy(data.originalScale).multiplyScalar(pulse);
                });
                
                // Animar brillo
                glowSprite.scale.setScalar(600 + 50 * Math.sin(time * 0.001));
                
                time++;
                
                renderer.render(scene, camera);
            }

            // Manejar redimensionamiento de ventana
            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            window.addEventListener('resize', onWindowResize, false);

            // Iniciar animaci√≥n
            animate();
        }
    </script>
</body>
</html>